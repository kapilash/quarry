#include "quarry_testsuites.h"
#include "quarry_kw.h"
#include <string.h>



START_TEST(test_KeywordsPositive)
{
  unsigned char input[20];
  int currKWsize,size,index,retval,expLine;
  qu_KWTablePtr kwTable;

  printf("\nRunning tests on keywords.");
  kwTable = quarry_util_keywordTableJava();

  currKWsize = strlen("abstract");
  memcpy(input,"abstract",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"abstract is a keyword");
  currKWsize = strlen("assert");
  memcpy(input,"assert",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"assert is a keyword");
  currKWsize = strlen("boolean");
  memcpy(input,"boolean",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"boolean is a keyword");
  currKWsize = strlen("break");
  memcpy(input,"break",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"break is a keyword");
  currKWsize = strlen("byte");
  memcpy(input,"byte",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"byte is a keyword");
  currKWsize = strlen("case");
  memcpy(input,"case",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"case is a keyword");
  currKWsize = strlen("catch");
  memcpy(input,"catch",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"catch is a keyword");
  currKWsize = strlen("char");
  memcpy(input,"char",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"char is a keyword");
  currKWsize = strlen("class");
  memcpy(input,"class",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"class is a keyword");
  currKWsize = strlen("const");
  memcpy(input,"const",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"const is a keyword");
  currKWsize = strlen("continue");
  memcpy(input,"continue",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"continue is a keyword");
  currKWsize = strlen("default");
  memcpy(input,"default",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"default is a keyword");
  currKWsize = strlen("do");
  memcpy(input,"do",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"do is a keyword");
  currKWsize = strlen("double");
  memcpy(input,"double",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"double is a keyword");
  currKWsize = strlen("else");
  memcpy(input,"else",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"else is a keyword");
  currKWsize = strlen("enum");
  memcpy(input,"enum",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"enum is a keyword");
  currKWsize = strlen("extends");
  memcpy(input,"extends",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"extends is a keyword");
  currKWsize = strlen("final");
  memcpy(input,"final",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"final is a keyword");
  currKWsize = strlen("finally");
  memcpy(input,"finally",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"finally is a keyword");
  currKWsize = strlen("float");
  memcpy(input,"float",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"float is a keyword");
  currKWsize = strlen("for");
  memcpy(input,"for",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"for is a keyword");
  currKWsize = strlen("if");
  memcpy(input,"if",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"if is a keyword");
  currKWsize = strlen("goto");
  memcpy(input,"goto",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"goto is a keyword");
  currKWsize = strlen("implements");
  memcpy(input,"implements",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"implements is a keyword");
  currKWsize = strlen("import");
  memcpy(input,"import",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"import is a keyword");
  currKWsize = strlen("instanceof");
  memcpy(input,"instanceof",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"instanceof is a keyword");
  currKWsize = strlen("int");
  memcpy(input,"int",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"int is a keyword");
  currKWsize = strlen("interface");
  memcpy(input,"interface",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"interface is a keyword");
  currKWsize = strlen("long");
  memcpy(input,"long",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"long is a keyword");
  currKWsize = strlen("native");
  memcpy(input,"native",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"native is a keyword");
  currKWsize = strlen("new");
  memcpy(input,"new",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"new is a keyword");
  currKWsize = strlen("package");
  memcpy(input,"package",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"package is a keyword");
  currKWsize = strlen("private");
  memcpy(input,"private",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"private is a keyword");
  currKWsize = strlen("protected");
  memcpy(input,"protected",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"protected is a keyword");
  currKWsize = strlen("public");
  memcpy(input,"public",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"public is a keyword");
  currKWsize = strlen("return");
  memcpy(input,"return",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"return is a keyword");
  currKWsize = strlen("short");
  memcpy(input,"short",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"short is a keyword");
  currKWsize = strlen("static");
  memcpy(input,"static",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"static is a keyword");
  currKWsize = strlen("strictfp");
  memcpy(input,"strictfp",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"strictfp is a keyword");
  currKWsize = strlen("super");
  memcpy(input,"super",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"super is a keyword");
  currKWsize = strlen("switch");
  memcpy(input,"switch",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"switch is a keyword");
  currKWsize = strlen("synchronized");
  memcpy(input,"synchronized",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"synchronized is a keyword");
  currKWsize = strlen("this");
  memcpy(input,"this",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"this is a keyword");
  currKWsize = strlen("throw");
  memcpy(input,"throw",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"throw is a keyword");
  currKWsize = strlen("throws");
  memcpy(input,"throws",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"throws is a keyword");
  currKWsize = strlen("transient");
  memcpy(input,"transient",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"transient is a keyword");
  currKWsize = strlen("try");
  memcpy(input,"try",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"try is a keyword");
  currKWsize = strlen("void");
  memcpy(input,"void",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"void is a keyword");
  currKWsize = strlen("volatile");
  memcpy(input,"volatile",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"volatile is a keyword");
  currKWsize = strlen("while");
  memcpy(input,"while",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 1),"while is a keyword");

}
END_TEST

START_TEST(test_KeywordsNegative)
{
  unsigned char input[50];
  int currKWsize,size,index,retval,expLine;
  qu_KWTablePtr kwTable;

  printf(".");
  kwTable = quarry_util_keywordTableJava();


  currKWsize = strlen("abstracts");
  memcpy(input,"abstracts",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"abstracts is not a keyword");
  currKWsize = strlen("asserted");
  memcpy(input,"asserted",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"asserted is not a keyword");
  currKWsize = strlen("boolea");
  memcpy(input,"boolea",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"boolea is not a keyword");
  currKWsize = strlen("breakbyte");
  memcpy(input,"breakbyte",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"breakbyte is not a keyword");
  currKWsize = strlen("cased");
  memcpy(input,"cased",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"cased is not a keyword");
  currKWsize = strlen("catchy");
  memcpy(input,"catchy",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"catchy is not a keyword");
  currKWsize = strlen("charclass");
  memcpy(input,"charclass",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"charclass is not a keyword");
  currKWsize = strlen("contineu");
  memcpy(input,"contineu",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"contineu is not a keyword");
  currKWsize = strlen("defaultdo");
  memcpy(input,"defaultdo",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"defaultdo is not a keyword");
  currKWsize = strlen("dodouble");
  memcpy(input,"dodouble",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"dodouble is not a keyword");
  currKWsize = strlen("finaly");
  memcpy(input,"finaly",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"finaly is not a keyword");
  currKWsize = strlen("floatf");
  memcpy(input,"floatf",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"floatf is not a keyword");
  currKWsize = strlen("voidv");
  memcpy(input,"voidv",currKWsize);
  retval = quarry_util_isKeyword(kwTable, input, currKWsize );
  fail_unless((retval == 0),"voidv is not a keyword");

}
END_TEST
void quarry_addKeywordTests(Suite *suite)
{
  TCase *tc_core = tcase_create("keywords");
  tcase_add_test (tc_core,test_KeywordsPositive);
  tcase_add_test (tc_core,test_KeywordsNegative);

  suite_add_tcase(suite,tc_core);
}

